<!-- 博文的布局-Layout -->
<!DOCTYPE html>
<html>
<head>
<!-- 引入head标签 -->
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-sclable=0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="description" content="分享技术和生活" />
<meta name="keywords" content="saygoodlolita, cheney, cheneymars" />
<link rel="stylesheet" href="/assets/css/style.css">
<link rel="stylesheet" href="/assets/css/media.css">
<link rel="stylesheet" href="/assets/css/animate.min.css">
<link rel="stylesheet" href="/assets/css/pygments/pygments_default.css">
<link rel="stylesheet" href="/assets/css/github-markdown.css">
<!-- SNS-icon -->
<script src="//at.alicdn.com/t/font_856428_y9z6nq7zf5.js"></script>
<!-- share.css -->
<link rel="stylesheet" href="/assets/css/share.min.css">
<!-- font -->
<link rel="stylesheet" href="/assets/css/font.css">
<!-- <link href="https://fonts.googleapis.com/css?family=Kaushan+Script|Pacifico|Ubuntu|Roboto+Mono|Source+Sans+Pro" rel="stylesheet"> -->

<!-- Favicon -->
<link href="/assets/profile.jpeg" rel="shortcut icon" />
<link href="/assets/profile.jpeg" rel="apple-touch-icon-precomposed" />
<!-- Android Lolipop Theme Color -->
<!-- <meta name="theme-color" content="#1464FB"> -->
<title>ReactiveCocoa(一)</title>
<!-- 百度统计 -->

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>

<!-- 谷歌分析 -->


<!-- Android Lolipop Theme Color -->
<meta name="theme-color" content=" rgb(255,210,32) ">
</head>
<body>

<!-- 顶部锚点 -->
<a id="htmlup" name="htmlup"></a>
<!-- 引入博文顶部选项 -->

<header id="post-header" style="background-color:rgb(255,210,32);">
  <div class="top-center">
      <div class="logo">
          <a href="/" title="my awesome webtitle" style="color: white;">Cheney</a>
      </div>
      <nav class="top-nav">
          <ul>
              
                <li><a href="/" style="color: white;">首页</a></li>
              
                <li><a href="/tags.html" style="color: white;">标签</a></li>
              
                <li><a href="/timeline.html" style="color: white;">时间线</a></li>
              
                <li><a href="/about.html" style="color: white;">关于博主</a></li>
              
          </ul>
      </nav>
      <div id="top-boot">
        <a href="javascript:;" id="boot1" style="display:block;" onclick="document.getElementById('boot-area').style.display='block';document.getElementById('boot1').style.display='none';document.getElementById('boot2').style.display='block';"><img src="/assets/boot_white.png" alt=""></a>
        <a href="javascript:;" id="boot2" style="display: none;" onclick="document.getElementById('boot-area').style.display='none';document.getElementById('boot1').style.display='block';document.getElementById('boot2').style.display='none';"><img src="/assets/boot_white.png" alt=""></a>
      </div>
  </div>

</header>


<!-- 引入移动下拉选项 -->
<div id="boot-area">
    <ul>
        
          <a href="/"><li>首页</li></a>
        
          <a href="/tags.html"><li>标签</li></a>
        
          <a href="/timeline.html"><li>时间线</li></a>
        
          <a href="/about.html"><li>关于博主</li></a>
        
    </ul>
</div>

<!-- 引入博文顶部样式 -->
<!-- 版本一 垃圾 -->
<!-- <div class="wow fadeIn top" data-wow-duration="3.5s" >
    <span class="wow fadeInUp" data-wow-delay="0.2s">ReactiveCocoa(一)</span>
    <span class="wow fadeInUp" data-wow-delay="0.4s"></span>
    <span class="wow fadeInUp" data-wow-delay="0.4s"></span>
    <span class="wow fadeInUp" data-wow-delay="0.6s">作者&nbsp;&nbsp;|&nbsp;&nbsp;Cheney</span>
</div> -->

<!-- 版本二 可切换页面 -->

<div class="post-top" style="background-color:rgb(255,210,32);">
  <!-- 页面宽度大于800px -->
  <div class="left-area">
    
      <a href="/2017/04/30/ReactiveCocoa(%E4%BA%8C).html" class="btn bounceInLeft animated" onmouseover="showLeft();this.style.color='rgb(255,210,32)';" onmouseout="goneLeft();this.style.color='rgba(0,0,0,.2)';"><</a>
      <div id="left-tab" style="display:none;"><span class="left-san"></span><span class="left-main" style="color:rgb(255,210,32);"><sapn class="main">ReactiveCocoa(二)</sapn></span></div>
    
  </div>
  <div class="post-titlearea">
    <span class="wow fadeInUp" data-wow-delay="0.2s">ReactiveCocoa(一)</span>
    <!-- <span class="wow fadeInUp" data-wow-delay="0.4s"></span> -->
    <!-- <span class="wow fadeInUp" data-wow-delay="0.4s"></span> -->
    <!-- <span class="wow fadeInUp" data-wow-delay="0.6s">作者&nbsp;&nbsp;|&nbsp;&nbsp;Cheney</span> -->
  </div>
  <div class="right-area">
    
      <a href="javascript:;" class="btn bounceInRight self-animated" onmouseover="showRight();this.style.color='rgb(255,210,32)';" onmouseout="goneRight();this.style.color='rgba(0,0,0,.2)';">></a>
      <div id="right-tab" style="display:none;"><span class="right-san"></span><span class="right-main" style="color:rgb(255,210,32);"><sapn class="main">没有下一页咯</sapn></span></div>
    
  </div>

  <!-- 页面宽度小于800px -->
  <div class="post-changearea">
    
      <a href="/2017/04/30/ReactiveCocoa(%E4%BA%8C).html" class="leftchange" style="border-right: 1px solid rgb(255,210,32);border-bottom: 2px solid rgb(255,210,32);"><span>上一篇<br><br>ReactiveCocoa(二)</span></a>
    
    
      <a href="javascript:;" class="rightchange" style="border-left: 1px solid rgb(255,210,32);border-bottom: 2px solid rgb(255,210,32);"><span><br>没有下一篇咯</span></a>
    
  </div>
</div>


<div class="markdown-body fadeInUp animated">

  

  <!-- 文章内容 -->
  <h1 id="reactivecocoa一">ReactiveCocoa(一)</h1>

<h2 id="reactivecocoa-简介">ReactiveCocoa 简介</h2>

<blockquote>
  <p>ReactiveCocoa is inspired by functional reactive programming. Rather than using mutable variables which are replaced and modified in-place, RAC offers “event streams,” represented by the Signal and SignalProducer types, that send values over time.</p>
</blockquote>

<p>ReactiveCocoa 的灵感来自函数式响应式编程(FRP). RAC 并不采用随时可变的变量, 而是用事件流(表现为<code class="highlighter-rouge">Signal</code>和<code class="highlighter-rouge">SignalProducer</code>)的方式来捕捉值的变化.</p>

<blockquote>
  <p>Event streams unify all of Cocoa’s common patterns for asynchrony and event handling, including:</p>
</blockquote>

<blockquote>
  <ul>
    <li>Delegate methods</li>
    <li>Callback blocks</li>
    <li>NSNotifications</li>
    <li>Control actions and responder chain events</li>
    <li>Futures and promises</li>
    <li>Key-value observing(KVO)</li>
  </ul>
</blockquote>

<p>在我们 iOS 开发过程中, 经常会响应某些事件来处理某些业务逻辑, 例如按钮的点击, 上下拉刷新, 网络请求, 属性的变化(通过 KVO)或者用户位置的变化(通过<code class="highlighter-rouge">CoreLocation</code>). 但是这些事件都用不同的方式来处理, 比如 action, delegate, KVO, callback 等.</p>

<p>其实这些事件, 都可以通过 RAC 处理, ReactiveCocoa 为事件提供了很多处理方法, 而且利用 RAC 处理事件很方便, 可以把要处理的事情, 和监听的事情的代码放在一起, 这样非常方便我们管理, 就不需要跳到对应的方法里, 非常符合我们开发中<strong>高内聚, 低耦合</strong>的思想.</p>

<h2 id="reactivecocoa-常见类">ReactiveCocoa 常见类</h2>

<h3 id="racsignal"><code class="highlighter-rouge">RACSignal</code></h3>

<p>信号类, 一般表示将来有数据传递, 只要有数据改变, 信号内部接收到数据, 就会马上发出数据. 注意是, 数据发出, 并不是信号类发出.</p>

<ul>
  <li>
    <p>信号类(<code class="highlighter-rouge">RACSignal</code>), 只是表示当数据改变时, 信号内部会发出数据, 它本身不具备发送信号的能力, 而是交给内部一个订阅者去发出.</p>
  </li>
  <li>
    <p>默认一个信号都是冷信号, 也就是值改变了, 也不会触发, 只有订阅了这个信号, 这个信号才会变为热信号, 值改变了才会触发.</p>
  </li>
  <li>
    <p>如何订阅信号: 调用信号<code class="highlighter-rouge">RACSignal</code>的<code class="highlighter-rouge">subscribeNext</code>就能订阅.</p>
  </li>
</ul>

<p><strong><code class="highlighter-rouge">RACSignal</code>使用步骤</strong>:</p>

<ol>
  <li>创建信号<code class="highlighter-rouge">+ (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe</code></li>
  <li>发送信号<code class="highlighter-rouge">- (void)sendNext:(id)value</code></li>
  <li>订阅信号, 才会激活信号<code class="highlighter-rouge">- (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock</code></li>
</ol>

<p><strong><code class="highlighter-rouge">RACSignal</code>底层实现</strong>：</p>

<ol>
  <li>创建子类信号<code class="highlighter-rouge">RACDynamicSignal</code>, 首先把<code class="highlighter-rouge">didSubscribe</code>这个 block 保存到信号<code class="highlighter-rouge">RACDynamicSignal</code>中, 但是还不会触发(冷信号).</li>
  <li>当信号被订阅, 也就是调用<code class="highlighter-rouge">signal</code>的<code class="highlighter-rouge">subscribeNext:nextBlock</code>. <code class="highlighter-rouge">subscribeNext</code>内部会创建订阅者<code class="highlighter-rouge">subscriber</code>, 并且把<code class="highlighter-rouge">nextBlock</code>保存到订阅者<code class="highlighter-rouge">subscriber</code>中, 此时为热信号.</li>
  <li><code class="highlighter-rouge">subscribeNext</code>内部会调用<code class="highlighter-rouge">RACDynamicSignal</code>的<code class="highlighter-rouge">didSubscribe</code>这个block. 通常也就是在<code class="highlighter-rouge">RACDynamicSignal</code>的<code class="highlighter-rouge">didSubscribe</code>中调用<code class="highlighter-rouge">[subscriber sendNext:@1]</code>.</li>
  <li><code class="highlighter-rouge">sendNext</code>底层其实就是执行订阅者<code class="highlighter-rouge">subscriber</code>的<code class="highlighter-rouge">nextBlock</code>.</li>
  <li>标记信号发送完成或者取消订阅.</li>
  <li>执行<code class="highlighter-rouge">RACDisposable</code>的<code class="highlighter-rouge">disposeBlock</code>中的代码.</li>
</ol>

<p>代码:</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 1. 创建信号 createSignal:didSubscribe(block)</span>
<span class="c1">// RACDisposable: 取消订阅</span>
<span class="c1">// RACSubscriber: 发送数据</span>
<span class="n">RACSignal</span> <span class="o">*</span> <span class="n">signal</span> <span class="o">=</span> <span class="p">[</span><span class="n">RACSignal</span> <span class="nf">createSignal</span><span class="p">:</span><span class="o">^</span><span class="n">RACDisposable</span> <span class="o">*</span> <span class="n">_Nullable</span><span class="p">(</span><span class="n">id</span><span class="o">&lt;</span><span class="n">RACSubscriber</span><span class="o">&gt;</span>  <span class="n">_Nonnull</span> <span class="n">subscriber</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// block 调用: 每当有订阅者订阅信号, 就会调用 block</span>
    <span class="c1">// block 作用: 描述当前信号那些数据需要发送</span>
    
    <span class="c1">// 3. 发送信号</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"调用了 didSubscribe"</span><span class="p">);</span>
    <span class="p">[</span><span class="n">subscriber</span> <span class="nf">sendNext</span><span class="p">:</span><span class="mi">@1</span><span class="p">];</span> <span class="c1">// 此处调用订阅者的 nextBlock</span>
    
    <span class="c1">// 5. 如果不在发送数据, 最好发送信号完成, 内部会自动调用 [RACDisposable disposable] 取消订阅信号. 或者信号想要被取消, 就必须返回一个 RACDisposable. 然后在后面 [disposable dispose]</span>
    <span class="p">[</span><span class="n">subscriber</span> <span class="nf">sendCompleted</span><span class="p">];</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">RACDisposable</span> <span class="nf">disposableWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
        <span class="c1">// 6. 信号什么时候被取消: 1. 自动取消, 当一个信号的订阅者被销毁的时候, 就会自动取消订阅. 2. 主动取消</span>
        <span class="c1">// block 调用: 一旦一个信号被取消订阅就会调用</span>
        <span class="c1">// block 作用: 当信号取消订阅时清空一些资源</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@"取消订阅"</span><span class="p">);</span>
    <span class="p">}];</span>
<span class="p">}];</span>

<span class="c1">// subscribeNext: 创建订阅者, 然后把 nextBlock 保存到订阅者里面</span>
<span class="c1">// 2. 订阅信号: 只要订阅信号, 就会返回一个取消订阅信号的类</span>
<span class="n">RACDisposable</span> <span class="o">*</span> <span class="n">disposable</span> <span class="o">=</span> <span class="p">[</span><span class="n">signal</span> <span class="nf">subscribeNext</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">id</span>  <span class="n">_Nullable</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 4. block 调用: 每当有信号发出数据, 就会调用 block</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"接受到数据: %@"</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
<span class="p">}];</span>
<span class="c1">// 5. 取消订阅</span>
<span class="c1">// [disposable dispose];</span>
</code></pre></div></div>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">调用了</span> <span class="n">didSubscribe</span>
<span class="err">接受到数据</span><span class="o">:</span> <span class="mi">1</span>
<span class="err">取消订阅</span>
</code></pre></div></div>

<h4 id="racsubscriber"><code class="highlighter-rouge">RACSubscriber</code></h4>

<p>表示订阅者的意思, 用于发送信号, 这是一个协议, 不是一个类, 只要遵守这个协议, 并且实现方法才能成为订阅者. 通过 create 创建的信号, 都有一个订阅者, 帮助他发送数据.</p>

<h4 id="racdisposable"><code class="highlighter-rouge">RACDisposable</code></h4>

<p>用于取消订阅或者清理资源, 当信号发送完成或者发送错误的时候, 就会自动触发它.</p>

<h3 id="racsubject"><code class="highlighter-rouge">RACSubject</code></h3>

<p>信号提供者, 自己可以充当信号, 又能发送信号.</p>

<p>使用场景: 通常用来代替代理, 有了它, 就不必要定义代理了.</p>

<p><strong><code class="highlighter-rouge">RACSubject</code>使用步骤</strong></p>

<ol>
  <li>创建信号<code class="highlighter-rouge">[RACSubject subject]</code>, 和<code class="highlighter-rouge">RACSignal</code>不一样, 创建信号时没有 block.</li>
  <li>订阅信号<code class="highlighter-rouge">- (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock</code>.</li>
  <li>发送信号<code class="highlighter-rouge">sendNext:(id)value</code>.</li>
</ol>

<p><code class="highlighter-rouge">RACSubject</code>底层实现和<code class="highlighter-rouge">RACSignal</code>不一样.</p>

<ol>
  <li>调用<code class="highlighter-rouge">subscribeNext</code>订阅信号, 只是把订阅者保存起来, 并且订阅者的 nextBlock 已经赋值了.</li>
  <li>调用<code class="highlighter-rouge">sendNext</code>发送信号, 遍历刚刚保存的所有订阅者, 一个一个调用订阅者的<code class="highlighter-rouge">nextBlock</code>, 所以一定要先订阅才能接受到数据.</li>
</ol>

<p>代码:</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// RACSubject: 信号提供者</span>
<span class="c1">// 1. 创建信号</span>
<span class="n">RACSubject</span> <span class="o">*</span> <span class="n">subject</span> <span class="o">=</span> <span class="p">[</span><span class="n">RACSubject</span> <span class="nf">subject</span><span class="p">];</span>
<span class="c1">// 2. 订阅信号</span>
<span class="p">[</span><span class="n">subject</span> <span class="nf">subscribeNext</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">id</span>  <span class="n">_Nullable</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 4. block 调用: 当有数据发出时就会调用</span>
    <span class="c1">// block 作用: 处理数据</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"第一个订阅者: %@"</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
<span class="p">}];</span>
<span class="c1">// 发送信号</span>
<span class="p">[</span><span class="n">subject</span> <span class="nf">sendNext</span><span class="p">:</span><span class="mi">@1</span><span class="p">];</span>

<span class="c1">// 2.1 第二次订阅信号</span>
<span class="p">[</span><span class="n">subject</span> <span class="nf">subscribeNext</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">id</span>  <span class="n">_Nullable</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"第二个订阅者: %@"</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
<span class="p">}];</span>
<span class="c1">// 3. 发送信号</span>
<span class="p">[</span><span class="n">subject</span> <span class="nf">sendNext</span><span class="p">:</span><span class="mi">@2</span><span class="p">];</span>
<span class="p">[</span><span class="n">subject</span> <span class="nf">sendNext</span><span class="p">:</span><span class="mi">@3</span><span class="p">];</span>
</code></pre></div></div>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">第一个订阅者</span><span class="o">:</span> <span class="mi">1</span>
<span class="err">第一个订阅者</span><span class="o">:</span> <span class="mi">2</span>
<span class="err">第二个订阅者</span><span class="o">:</span> <span class="mi">2</span>
<span class="err">第一个订阅者</span><span class="o">:</span> <span class="mi">3</span>
<span class="err">第二个订阅者</span><span class="o">:</span> <span class="mi">3</span>
</code></pre></div></div>

<h4 id="racreplaysubject"><code class="highlighter-rouge">RACReplaySubject</code></h4>

<p>重复提供信号类, <code class="highlighter-rouge">RACSubject</code>的子类.</p>

<p>使用场景一: 如果一个信号每被订阅一次, 就需要把之前的值重复发送一遍, 使用重复提供信号类. 
使用场景二: 可以设置<code class="highlighter-rouge">capacity</code>数量来限制缓存的 value 的数量, 即只缓充最新的几个值.</p>

<ol>
  <li>创建信号<code class="highlighter-rouge">[RACReplaySubject subject]</code>, 跟<code class="highlighter-rouge">RACSignal</code>不一样, 创建信号时没有 block.</li>
  <li>可以先订阅信号, 也可以先发送信号.
    <ol>
      <li>订阅信号<code class="highlighter-rouge">- (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock</code></li>
      <li>发送信号<code class="highlighter-rouge">sendNext:(id)value</code></li>
    </ol>
  </li>
</ol>

<p><code class="highlighter-rouge">RACReplaySubject</code>底层实现和<code class="highlighter-rouge">RACSubject</code>不一样.</p>

<ol>
  <li>调用<code class="highlighter-rouge">sendNext</code>发送信号, 把值保存起来, 然后遍历刚刚保存的所有订阅者, 一个一个调用订阅者的nextBlock.</li>
  <li>调用<code class="highlighter-rouge">subscribeNext</code>订阅信号, 遍历保存的所有值, 一个一个调用订阅者的<code class="highlighter-rouge">nextBlock</code>.</li>
</ol>

<p>如果想当一个信号被订阅, 就重复播放之前所有值, 需要先发送信号, 再订阅信号. <strong>也就是先保存值，再订阅值</strong>。</p>

<p>代码:</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 1. 创建信号</span>
<span class="n">RACReplaySubject</span> <span class="o">*</span> <span class="n">subject</span> <span class="o">=</span> <span class="p">[</span><span class="n">RACReplaySubject</span> <span class="nf">subject</span><span class="p">];</span>
<span class="c1">// 2. 订阅信号</span>
<span class="p">[</span><span class="n">subject</span> <span class="nf">subscribeNext</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">id</span>  <span class="n">_Nullable</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"第一个订阅者: %@"</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
<span class="p">}];</span>
<span class="c1">// 3. 发送信号</span>
<span class="p">[</span><span class="n">subject</span> <span class="nf">sendNext</span><span class="p">:</span><span class="mi">@1</span><span class="p">];</span>
<span class="p">[</span><span class="n">subject</span>  <span class="nf">sendNext</span><span class="p">:</span><span class="mi">@2</span><span class="p">];</span>
<span class="p">[</span><span class="n">subject</span> <span class="nf">subscribeNext</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">id</span>  <span class="n">_Nullable</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"第二个订阅者: %@"</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
<span class="p">}];</span>
</code></pre></div></div>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">第一个订阅者</span><span class="o">:</span> <span class="mi">1</span>
<span class="err">第一个订阅者</span><span class="o">:</span> <span class="mi">2</span>
<span class="err">第二个订阅者</span><span class="o">:</span> <span class="mi">1</span>
<span class="err">第二个订阅者</span><span class="o">:</span> <span class="mi">2</span>
</code></pre></div></div>

<p>从输出中看出, 无论<code class="highlighter-rouge">sendNext</code>在订阅之前还是之后, 输出不变. 而<code class="highlighter-rouge">RACSubject</code>同样的代码顺序则会输出:</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">第一个订阅者</span><span class="o">:</span> <span class="mi">1</span>
<span class="err">第一个订阅者</span><span class="o">:</span> <span class="mi">2</span>
</code></pre></div></div>

<p>也就是在<code class="highlighter-rouge">sendNext</code>后面订阅的信号已经不管用了.</p>

<h3 id="ractuple"><code class="highlighter-rouge">RACTuple</code></h3>

<p>元组类, 类似<code class="highlighter-rouge">NSArray</code>, 用来包装值.</p>

<p><code class="highlighter-rouge">RACTupleUnpack</code>宏: 专门用来解析元组. 等号右边: 需要解析的元组. 宏的参数: 填解析数据的类型. 元组里面有几个值, 宏的参数就必须填几个.</p>

<p>代码:</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 遍历字典, 遍历出来的键值对会包装成 RACTuple (元组对象)</span>
<span class="n">NSDictionary</span> <span class="o">*</span> <span class="n">dict</span> <span class="o">=</span> <span class="p">@{</span><span class="s">@"name"</span><span class="o">:</span><span class="s">@"Cheney"</span><span class="p">,</span> <span class="s">@"age"</span><span class="o">:</span><span class="mi">@18</span><span class="p">};</span>
<span class="p">[</span><span class="n">dict</span><span class="p">.</span><span class="n">rac_sequence</span><span class="p">.</span><span class="n">signal</span> <span class="nf">subscribeNext</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">id</span>  <span class="n">_Nullable</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
   <span class="c1">// 解包元组, 会把元组的值按顺序给参数的变量赋值</span>
    <span class="n">RACTupleUnpack</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span> <span class="n">key</span><span class="p">,</span> <span class="n">NSString</span> <span class="o">*</span> <span class="n">value</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="c1">// 相当于以下写法</span>
    <span class="c1">// NSString * key = x[0];</span>
    <span class="c1">// NSString * value = x[1];</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"%@ %@"</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}];</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>name Cheney
age 18
</code></pre></div></div>

<h3 id="racsequence"><code class="highlighter-rouge">RACSequence</code></h3>

<p>RAC 中的集合类, 用于代替<code class="highlighter-rouge">NSArray</code>和<code class="highlighter-rouge">NSDictionary</code>, 可以使用它来快速遍历数组和字典. 可以用来字典转模型等. (据说性能很差)</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 遍历数组</span>
<span class="n">NSArray</span> <span class="o">*</span> <span class="n">array</span> <span class="o">=</span> <span class="p">@[</span><span class="mi">@1</span><span class="p">,</span> <span class="mi">@2</span><span class="p">,</span> <span class="mi">@3</span><span class="p">];</span>
<span class="c1">// 把数组转换成集合 RACSequence: aray.rac_sequence</span>
<span class="c1">// 把集合转化为信号</span>
<span class="c1">// 订阅信号, 会把集合中的所有值遍历出来</span>
<span class="p">[</span><span class="n">array</span><span class="p">.</span><span class="n">rac_sequence</span><span class="p">.</span><span class="n">signal</span> <span class="nf">subscribeNext</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">id</span>  <span class="n">_Nullable</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"%@"</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
<span class="p">}];</span>
</code></pre></div></div>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span>
<span class="mi">2</span>
<span class="mi">3</span>
</code></pre></div></div>

<p>字典转模型：</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">NSDictionary</span> <span class="o">*</span> <span class="n">dict1</span> <span class="o">=</span> <span class="p">@{</span><span class="s">@"name"</span><span class="o">:</span><span class="s">@"Cheney"</span><span class="p">,</span> <span class="s">@"age"</span><span class="o">:</span><span class="mi">@18</span><span class="p">};</span>
<span class="n">NSDictionary</span> <span class="o">*</span> <span class="n">dict2</span> <span class="o">=</span> <span class="p">@{</span><span class="s">@"name"</span><span class="o">:</span><span class="s">@"bobo"</span><span class="p">,</span> <span class="s">@"age"</span><span class="o">:</span><span class="mi">@18</span><span class="p">};</span>
<span class="n">NSArray</span> <span class="o">*</span> <span class="n">dictArr</span> <span class="o">=</span> <span class="p">@[</span><span class="n">dict1</span><span class="p">,</span> <span class="n">dict2</span><span class="p">];</span>
<span class="c1">// map: 映射, 吧原始的 value 值映射成一个新值</span>
<span class="c1">// array: 把集合转换成数组</span>
<span class="c1">// 当信号被订阅时, 遍历集合中的原始值, 映射成新值, 保存到新的数组</span>
<span class="n">NSArray</span> <span class="o">*</span> <span class="n">perArr</span> <span class="o">=</span> <span class="p">[[</span><span class="n">dictArr</span><span class="p">.</span><span class="n">rac_sequence</span> <span class="nf">map</span><span class="p">:</span><span class="o">^</span><span class="n">id</span> <span class="n">_Nullable</span><span class="p">(</span><span class="n">id</span>  <span class="n">_Nullable</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">Person</span> <span class="nf">personWithDic</span><span class="p">:</span><span class="n">value</span><span class="p">];</span>
<span class="p">}]</span><span class="nf">array</span><span class="p">];</span>
<span class="n">NSLog</span><span class="p">(</span><span class="s">@"%@"</span><span class="p">,</span> <span class="n">perArr</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="raccommand"><code class="highlighter-rouge">RACCommand</code></h3>

<p>RAC 中用于处理事件的类, 可以把事件如何处理, 事件中的数据如何传递, 包装到这个类中, 他可以很方便的监控事件的执行过程.</p>

<p>使用场景: 监听按钮点击, 网络请求.</p>

<ul>
  <li><code class="highlighter-rouge">RACCommand</code>使用步骤:</li>
</ul>

<ol>
  <li>创建命令<code class="highlighter-rouge">initWithSignalBlock:(RACSignal * (^)(id input))signalBlock</code></li>
  <li>在<code class="highlighter-rouge">signalBlock</code>中, 创建<code class="highlighter-rouge">RACSignal</code>, 并且作为<code class="highlighter-rouge">signalBlock</code>的返回值</li>
  <li>执行命令<code class="highlighter-rouge">- (RACSignal *)execute:(id)input</code></li>
</ol>

<ul>
  <li><code class="highlighter-rouge">RACCommand</code>使用注意:</li>
</ul>

<ol>
  <li><code class="highlighter-rouge">signalBlock</code>必须要返回一个信号, 不能传 nil.</li>
  <li>如果不想要传递信号, 直接创建空的信号<code class="highlighter-rouge">[RACSignal empty]</code>.</li>
  <li><code class="highlighter-rouge">RACCommand</code>中信号如果数据传递完, 必须调用<code class="highlighter-rouge">[subscriber sendCompleted]</code>, 这时命令才会执行完毕, 否则永远处于执行中.</li>
  <li><code class="highlighter-rouge">RACCommand</code>需要被强引用, 否则接收不到<code class="highlighter-rouge">RACCommand</code>中的信号, 因此<code class="highlighter-rouge">RACCommand</code>中的信号是延迟发送的.</li>
</ol>

<ul>
  <li><code class="highlighter-rouge">RACCommand</code>设计思想: 内部<code class="highlighter-rouge">signalBlock</code>为什么要返回一个信号, 这个信号有什么用.</li>
</ul>

<ol>
  <li>在RAC开发中, 通常会把网络请求封装到<code class="highlighter-rouge">RACCommand</code>, 直接执行某个<code class="highlighter-rouge">RACCommand</code>就能发送请求.</li>
  <li>当<code class="highlighter-rouge">RACCommand</code>内部请求到数据的时候, 需要把请求的数据传递给外界, 这时候就需要通过<code class="highlighter-rouge">signalBlock</code>返回的信号传递了.</li>
</ol>

<ul>
  <li>如何拿到<code class="highlighter-rouge">RACCommand</code>中返回信号发出的数据.</li>
</ul>

<ol>
  <li><code class="highlighter-rouge">RACCommand</code>有个执行信号源<code class="highlighter-rouge">executionSignals</code>, 这个是<code class="highlighter-rouge">signal of signals</code>(信号的信号), 意思是信号发出的数据是信号, 不是普通的类型.</li>
  <li>订阅<code class="highlighter-rouge">executionSignals</code>就能拿到<code class="highlighter-rouge">RACCommand</code>中返回的信号, 然后订阅<code class="highlighter-rouge">signalBlock</code>返回的信号, 就能获取发出的值.</li>
</ol>

<ul>
  <li>监听当前命令是否正在执行executing.</li>
</ul>

<p>代码:</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 1. 创建命令</span>
<span class="n">RACCommand</span> <span class="o">*</span> <span class="n">command</span> <span class="o">=</span> <span class="p">[</span><span class="n">RACCommand</span><span class="p">.</span><span class="n">alloc</span> <span class="nf">initWithSignalBlock</span><span class="p">:</span><span class="o">^</span><span class="n">RACSignal</span> <span class="o">*</span> <span class="n">_Nonnull</span><span class="p">(</span><span class="n">id</span>  <span class="n">_Nullable</span> <span class="n">input</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// block 调用: 当执行这个命令类的时候就会调用</span>
    <span class="c1">// block 作用: 描述如何处理事件, 网络请求</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"执行命令: %@"</span><span class="p">,</span> <span class="n">input</span><span class="p">);</span>
    <span class="c1">// 创建空信号, 必须返回信号</span>
    <span class="c1">// return RACSignal.empty;</span>
    <span class="c1">// 2. RACCommand 必须返回信号, 处理事件产生的数据就通过返回的信号发出. 注意: 数据传递完, 最好调用 sendCompleted, 这时命令才执行完毕.</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">RACSignal</span> <span class="nf">createSignal</span><span class="p">:</span><span class="o">^</span><span class="n">RACDisposable</span> <span class="o">*</span> <span class="n">_Nullable</span><span class="p">(</span><span class="n">id</span><span class="o">&lt;</span><span class="n">RACSubscriber</span><span class="o">&gt;</span>  <span class="n">_Nonnull</span> <span class="n">subscriber</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// block 调用: 当信号被订阅时被调用</span>
        <span class="c1">// block 作用: 发送处理事件的信号</span>
        <span class="p">[</span><span class="n">subscriber</span> <span class="nf">sendNext</span><span class="p">:</span><span class="s">@"信号发出的内容"</span><span class="p">];</span>
        <span class="p">[</span><span class="n">subscriber</span> <span class="nf">sendCompleted</span><span class="p">];</span>
        <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
    <span class="p">}];</span>
<span class="p">}];</span>
<span class="c1">// executionSignals: 信号源, 包含事件处理的所有信号.</span>
<span class="c1">// executionSignals: signalOfSignals, 信号中信号, 就是信号发出的数据也是信号</span>
<span class="c1">// switchToLatest: 用于 signalOfSignals, 获取 signalOfSignals 发出的最新信号, 也就是直接拿到 RACCommand 的信号</span>
<span class="c1">// 3. 如果想要h订阅接受信号源的信号内容, 必须保证命令不被销毁</span>
<span class="p">[</span><span class="n">command</span><span class="p">.</span><span class="n">executionSignals</span><span class="p">.</span><span class="n">switchToLatest</span> <span class="nf">subscribeNext</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">id</span>  <span class="n">_Nullable</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"%@"</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
<span class="p">}];</span>
<span class="c1">// 4. 执行命令, 调用 signalBlock</span>
<span class="p">[</span><span class="n">command</span> <span class="nf">execute</span><span class="p">:</span><span class="mi">@1</span><span class="p">];</span>
<span class="c1">// 5. 监听命令是否执行完毕, 默认会来一次, 可以直接跳过, skip 表示跳过第一次信号</span>
<span class="p">[[</span><span class="n">command</span><span class="p">.</span><span class="n">executing</span> <span class="nf">skip</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span> <span class="nf">subscribeNext</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">NSNumber</span> <span class="o">*</span> <span class="n">_Nullable</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">boolValue</span> <span class="o">==</span> <span class="nb">YES</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@"正在执行"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@"执行完成"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}];</span>
</code></pre></div></div>

<h3 id="racmulticastconnection"><code class="highlighter-rouge">RACMulticastConnection</code></h3>
<p>用于当一个信号被多次订阅时, 为了保证创建信号时<strong>避免多次调用创建信号中的 block</strong>, 造成副作用, 可以使用这个类处理.</p>
<ul>
  <li><code class="highlighter-rouge">RACMulticastConnection</code>使用步骤:</li>
</ul>

<ol>
  <li>创建信号<code class="highlighter-rouge">+ (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe</code></li>
  <li>创建连接<code class="highlighter-rouge">RACMulticastConnection * connect = [signal publish];</code></li>
  <li>订阅信号. 注意: 订阅的不在是之前的信号, 而是连接的信号. <code class="highlighter-rouge">[connect.signal subscribeNext:nextBlock]</code></li>
  <li>连接<code class="highlighter-rouge">[connect connect]</code></li>
</ol>

<ul>
  <li><code class="highlighter-rouge">RACMulticastConnection</code>底层原理:</li>
</ul>

<ol>
  <li>创建<code class="highlighter-rouge">connect</code>, <code class="highlighter-rouge">connect.sourceSignal</code> -&gt; <code class="highlighter-rouge">RACSignal</code>(原始信号) <code class="highlighter-rouge">connect.signal</code> -&gt; <code class="highlighter-rouge">RACSubject</code>.</li>
  <li>订阅<code class="highlighter-rouge">connect.signal</code>, 会调用<code class="highlighter-rouge">RACSubject</code>的<code class="highlighter-rouge">subscribeNext</code>, 创建订阅者, 而且把订阅者保存起来, 不会执行 block.</li>
  <li><code class="highlighter-rouge">[connect connect]</code>内部会订阅<code class="highlighter-rouge">RACSignal</code>(原始信号), 并且订阅者是<code class="highlighter-rouge">RACSubject</code>.
    <ol>
      <li>订阅原始信号, 就会调用原始信号中的<code class="highlighter-rouge">didSubscribe</code>.</li>
      <li><code class="highlighter-rouge">didSubscribe</code>, 拿到订阅者调用<code class="highlighter-rouge">sendNext</code>, 其实是调用<code class="highlighter-rouge">RACSubject</code>的<code class="highlighter-rouge">sendNext</code>.</li>
    </ol>
  </li>
  <li><code class="highlighter-rouge">RACSubject</code>的<code class="highlighter-rouge">sendNext</code>, 会遍历<code class="highlighter-rouge">RACSubject</code>所有订阅者发送信号.
    <ol>
      <li>因为刚刚第二步, 都是在订阅<code class="highlighter-rouge">RACSubject</code>, 因此会拿到第二步所有的订阅者, 调用他们的<code class="highlighter-rouge">nextBlock</code>.</li>
    </ol>
  </li>
</ol>

<p>需求: 假设在一个信号中发送请求, 每次订阅一次都会发送请求, 这样就会导致多次请求. 
解决: 使用 RACMulticastConnection 就能解决.</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 发送请求, 用一个信号内包装, 不管有多少个订阅者, 只想要发送一次请求</span>
<span class="n">RACSignal</span> <span class="o">*</span> <span class="n">signal</span> <span class="o">=</span> <span class="p">[</span><span class="n">RACSignal</span> <span class="nf">createSignal</span><span class="p">:</span><span class="o">^</span><span class="n">RACDisposable</span> <span class="o">*</span><span class="p">(</span><span class="n">id</span><span class="o">&lt;</span><span class="n">RACSubscriber</span><span class="o">&gt;</span> <span class="n">subscriber</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// didSubscribe(block)中的代码都统称为副作用 (Side Effects).</span>
    <span class="c1">// 发送请求</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"发送请求"</span><span class="p">);</span>
    <span class="p">[</span><span class="n">subscriber</span> <span class="nf">sendNext</span><span class="p">:</span><span class="mi">@1</span><span class="p">];</span>
    <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
<span class="p">}];</span>
<span class="c1">// 订阅信号</span>
<span class="p">[</span><span class="n">signal</span> <span class="nf">subscribeNext</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">id</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"接收数据: %@"</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>
<span class="p">}];</span>
<span class="p">[</span><span class="n">signal</span> <span class="nf">subscribeNext</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">id</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"接收数据: %@"</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>
<span class="p">}];</span>
</code></pre></div></div>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">发送请求</span>
<span class="err">接收数据</span><span class="o">:</span> <span class="mi">1</span>
<span class="err">发送请求</span>
<span class="err">接收数据</span><span class="o">:</span> <span class="mi">1</span>
</code></pre></div></div>
<p>运行结果会执行两遍发送请求, 也就是每次订阅都会发送一次请求.</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// RACMulticastConnection: 解决重复请求问题</span>
<span class="c1">// 1. 创建信号</span>
<span class="n">RACSignal</span> <span class="o">*</span> <span class="n">signal</span> <span class="o">=</span> <span class="p">[</span><span class="n">RACSignal</span> <span class="nf">createSignal</span><span class="p">:</span><span class="o">^</span><span class="n">RACDisposable</span> <span class="o">*</span><span class="p">(</span><span class="n">id</span><span class="o">&lt;</span><span class="n">RACSubscriber</span><span class="o">&gt;</span> <span class="n">subscriber</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"发送请求"</span><span class="p">);</span>
    <span class="p">[</span><span class="n">subscriber</span> <span class="nf">sendNext</span><span class="p">:</span><span class="mi">@1</span><span class="p">];</span>
    <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
<span class="p">}];</span>
<span class="c1">// 2. 创建连接</span>
<span class="n">RACMulticastConnection</span> <span class="o">*</span> <span class="n">connect</span> <span class="o">=</span> <span class="n">signal</span><span class="p">.</span><span class="n">publish</span><span class="p">;</span>
<span class="c1">// 3. 订阅信号</span>
<span class="c1">// 注意: 订阅信号也不能激活信号, 只是保存订阅者到数组, 必须通过连接, 当调用连接就会一次性调用所有订阅者的 sendNext:</span>
<span class="p">[</span><span class="n">connect</span><span class="p">.</span><span class="n">signal</span> <span class="nf">subscribeNext</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">id</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"订阅者一信号"</span><span class="p">);</span>
<span class="p">}];</span>
<span class="p">[</span><span class="n">connect</span><span class="p">.</span><span class="n">signal</span> <span class="nf">subscribeNext</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">id</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"订阅者二信号"</span><span class="p">);</span>
<span class="p">}];</span>
<span class="c1">// 4. 连接, 激活信号</span>
<span class="p">[</span><span class="n">connect</span> <span class="nf">connect</span><span class="p">];</span>
</code></pre></div></div>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">发送请求</span>
<span class="err">订阅者一信号</span>
<span class="err">订阅者二信号</span>
</code></pre></div></div>
<h3 id="racschedule"><code class="highlighter-rouge">RACSchedule</code></h3>

<p>RAC 中的队列, 用 GCD 封装的.</p>

<h3 id="racunit"><code class="highlighter-rouge">RACUnit</code></h3>

<p>表⽰ stream 不包含有意义的值, 也就是看到这个, 可以直接理解为 nil.</p>

<h3 id="racevent"><code class="highlighter-rouge">RACEvent</code></h3>

<p>把数据包装成信号事件(<code class="highlighter-rouge">signal event</code>). 它主要通过<code class="highlighter-rouge">RACSignal</code>的<code class="highlighter-rouge">-materialize</code>来使用.</p>

  <!-- 引入share模块 -->
  
  <div class="social-share-wrapper">
    <div class="social-share"></div>
  </div>


<!-- share.js -->
<script src="/assets/js/social-share.min.js"></script>
<script>
  socialShare('.social-share', {
    sites: [
      
        'qq'
        ,
        
      
        'wechat'
        ,
        
      
        'weibo'
        ,
        
      
        'twitter'
        ,
        
      
        'facebook'
        
      
    ],
    wechatQrcodeTitle: "分享到微信朋友圈",
    wechatQrcodeHelper: '期待在朋友圈见到这篇文章'
  });
</script>

</div>

<!-- 底部锚点 -->
<a id="htmldown" name="htmldown"></a>
<!-- 引入评论模块 -->



    <section class="post-footer-item comment">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zNDI2OS8xMDgwNg=="></div>
    </section>

    <!-- 来必力City版安装代码 -->
    <script type="text/javascript">
       (function(d, s) {
           var j, e = d.getElementsByTagName(s)[0];

           if (typeof LivereTower === 'function') { return; }

           j = d.createElement(s);
           j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
           j.async = true;

           e.parentNode.insertBefore(j, e);
       })(document, 'script');
    </script>
    <noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
    <!-- City版安装代码已完成 -->





<!-- 引入goto模块 -->
<div class="bounceInRight animated go">
  <a title="顶部切换页面" class="gototop" href="#htmlup" target="_self">
    <div class="box" style="font-family:'ffad_matroregular';">
        Top
    </div>
  </a>
  <a title="底部有livere评论哦" class="gotobottom" href="#htmldown" target="_self">
    <div class="box" style="font-family:'ffad_matroregular';">
        Foot
    </div>
  </a>
</div>

<!-- 引入页面底部模块 -->
<footer id="bottom">
  <br>
  <span>Cheney ©
  
  
    2018
    -
  
  2019
  <br>
  Powered by <a href="https://www.jekyll.com.cn/">Jekyll</a> | <a href="https://github.com/xukimseven/HardCandy-Jekyll">HardCandy-Jekyll</a></span>
</footer>


<!-- 引用wow.js的动画效果 -->
<script src="/assets/js/wow.js"></script>
<script>
    var wow = new WOW({
        boxClass: 'wow',
        animateClass: 'animated',
        // offset: 600,
        mobile: true,
        live: true
    });
    wow.init();
</script>
<!-- 页面刷新回到顶部 -->
<script>
    window.onbeforeunload = function(){
        //刷新后页面自动回到顶部
        document.documentElement.scrollTop = 0;  //ie下
        document.body.scrollTop = 0;  //非ie
    }
</script>
<script src="/assets/js/main.js"></script>
</body>
</html>
